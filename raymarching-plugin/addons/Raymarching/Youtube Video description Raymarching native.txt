This video shows the early build of my Godot Raymarching plugin. It has been under development for about a month now and I have designed it to be as native as possible, using Godots transform values and Node integration. This allows for seamless integration. The plugin comprises of different Nodes using a custom template for SDF functions and SDF function modifiers. These are selected and applied with the Shape-Manager Node, and are visible using the RayMarching camera Node. The custom camera applies a single vertex over the screen to allow for full screen fragment rendering necessary for RayMarching. The camera also contains the RayMarching settings like surface detail and iteration count. Upon starting the scene and during tool view the shader creator script builds the glsl needed for rendering, rebuilding when necessary. For example when the shape selection changes, but not rebuilding upon a parameter update like transforms being edited.

The plugin is currently under construction and I aim to release it when its core functionality is complete. The core functionality is to mostly capture the programming freedom possible with RayMarching to be available in the organized format of the Godot engine. With RayMarching its possible to do basically anything you can imagine, and this flexibility requires an adaptive shader creator reflecting this.

Raymarching is not very widespread for rendering and I have not seen it used in games, but it can be very powerful. Geometric detail made from math can be infinite. With layers of math applied upon each other there is much to yet invent and uncover.
#godot #rendering #glsl #raymarching
(The Thumbnail is not part of the video due to performance limitations of my Nvidia 940MX. Actually it speaks for Raymarching to show this all in real time, even the Mandelbulb mostly. Though there are performance improvements to be implemented, like a bounding volume hierarchy and object culling using invisble spheres.)